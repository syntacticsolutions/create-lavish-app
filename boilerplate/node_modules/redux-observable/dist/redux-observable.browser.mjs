import{Observable as S,Subject as h}from"rxjs";var s=class extends S{value;__notifier=new h;constructor(o,e){super(t=>{let n=this.__notifier.subscribe(t);return n&&!n.closed&&t.next(this.value),n}),this.value=e,o.subscribe(t=>{t!==this.value&&(this.value=t,this.__notifier.next(t))})}};import{merge as x}from"rxjs";function O(...r){let o=(...e)=>x(...r.map(t=>{let n=t(...e);if(!n)throw new TypeError(`combineEpics: one of the provided Epics "${t.name||"<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`);return n}));try{Object.defineProperty(o,"name",{value:`combineEpics(${r.map(e=>e.name||"<anonymous>").join(", ")})`})}catch{}return o}import{Subject as c,from as D,queueScheduler as f}from"rxjs";import{map as M,mergeMap as g,observeOn as a,subscribeOn as T}from"rxjs/operators";var v={},I=()=>{v={}},R=typeof console=="object"&&typeof console.warn=="function"?console.warn.bind(console):()=>{};function _(r={}){let o=f.constructor,e=new o(f.schedulerActionCtor),t=new c,n,d=u=>{n=u;let l=new c,m=new c,y=l.asObservable().pipe(a(e)),E=new s(m.pipe(a(e)),n.getState());return t.pipe(M(i=>{let p=i(y,E,r.dependencies);if(!p)throw new TypeError(`Your root Epic "${i.name||"<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`);return p}),g(i=>D(i).pipe(T(e),a(e)))).subscribe(n.dispatch),i=>p=>{let b=i(p);return m.next(n.getState()),l.next(p),b}};return d.run=u=>{t.next(u)},d}import{isAction as w}from"redux";import{filter as $}from"rxjs/operators";function N(...r){let o=r.length;return $(o===1?e=>w(e)&&e.type===r[0]:e=>{if(w(e)){for(let t=0;t<o;t++)if(e.type===r[t])return!0}return!1})}export{s as StateObservable,I as __FOR_TESTING__resetDeprecationsSeen,O as combineEpics,_ as createEpicMiddleware,N as ofType};
//# sourceMappingURL=redux-observable.browser.mjs.map