"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  StateObservable: () => StateObservable,
  __FOR_TESTING__resetDeprecationsSeen: () => resetDeprecationsSeen,
  combineEpics: () => combineEpics,
  createEpicMiddleware: () => createEpicMiddleware,
  ofType: () => ofType
});
module.exports = __toCommonJS(src_exports);

// src/StateObservable.ts
var import_rxjs = require("rxjs");
var StateObservable = class extends import_rxjs.Observable {
  value;
  __notifier = new import_rxjs.Subject();
  constructor(input$, initialState) {
    super((subscriber) => {
      const subscription = this.__notifier.subscribe(subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this.value);
      }
      return subscription;
    });
    this.value = initialState;
    input$.subscribe((value) => {
      if (value !== this.value) {
        this.value = value;
        this.__notifier.next(value);
      }
    });
  }
};

// src/combineEpics.ts
var import_rxjs2 = require("rxjs");
function combineEpics(...epics) {
  const merger = (...args) => (0, import_rxjs2.merge)(
    ...epics.map((epic) => {
      const output$ = epic(...args);
      if (!output$) {
        throw new TypeError(
          `combineEpics: one of the provided Epics "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
        );
      }
      return output$;
    })
  );
  try {
    Object.defineProperty(merger, "name", {
      value: `combineEpics(${epics.map((epic) => epic.name || "<anonymous>").join(", ")})`
    });
  } catch (e) {
  }
  return merger;
}

// src/createEpicMiddleware.ts
var import_rxjs3 = require("rxjs");
var import_operators = require("rxjs/operators");

// src/utils/console.ts
var deprecationsSeen = {};
var resetDeprecationsSeen = () => {
  deprecationsSeen = {};
};
var consoleWarn = typeof console === "object" && typeof console.warn === "function" ? console.warn.bind(console) : () => {
};
var warn = (msg) => {
  consoleWarn(`redux-observable | WARNING: ${msg}`);
};

// src/createEpicMiddleware.ts
function createEpicMiddleware(options = {}) {
  const QueueScheduler = import_rxjs3.queueScheduler.constructor;
  const uniqueQueueScheduler = new QueueScheduler(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    import_rxjs3.queueScheduler.schedulerActionCtor
  );
  if (process.env.NODE_ENV !== "production" && typeof options === "function") {
    throw new TypeError(
      "Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\n\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware"
    );
  }
  const epic$ = new import_rxjs3.Subject();
  let store;
  const epicMiddleware = (_store) => {
    if (process.env.NODE_ENV !== "production" && store) {
      warn(
        "this middleware is already associated with a store. createEpicMiddleware should be called for every store.\n\nLearn more: https://goo.gl/2GQ7Da"
      );
    }
    store = _store;
    const actionSubject$ = new import_rxjs3.Subject();
    const stateSubject$ = new import_rxjs3.Subject();
    const action$ = actionSubject$.asObservable().pipe((0, import_operators.observeOn)(uniqueQueueScheduler));
    const state$ = new StateObservable(
      stateSubject$.pipe((0, import_operators.observeOn)(uniqueQueueScheduler)),
      store.getState()
    );
    const result$ = epic$.pipe(
      (0, import_operators.map)((epic) => {
        const output$ = epic(action$, state$, options.dependencies);
        if (!output$) {
          throw new TypeError(
            `Your root Epic "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
          );
        }
        return output$;
      }),
      (0, import_operators.mergeMap)(
        (output$) => (0, import_rxjs3.from)(output$).pipe(
          (0, import_operators.subscribeOn)(uniqueQueueScheduler),
          (0, import_operators.observeOn)(uniqueQueueScheduler)
        )
      )
    );
    result$.subscribe(store.dispatch);
    return (next) => {
      return (action) => {
        const result = next(action);
        stateSubject$.next(store.getState());
        actionSubject$.next(action);
        return result;
      };
    };
  };
  epicMiddleware.run = (rootEpic) => {
    if (process.env.NODE_ENV !== "production" && !store) {
      warn(
        "epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first."
      );
    }
    epic$.next(rootEpic);
  };
  return epicMiddleware;
}

// src/operators.ts
var import_redux = require("redux");
var import_operators2 = require("rxjs/operators");
function ofType(...types) {
  const len = types.length;
  if (process.env.NODE_ENV !== "production") {
    if (len === 0) {
      warn("ofType was called without any types!");
    }
    if (types.some((key) => key === null || key === void 0)) {
      warn("ofType was called with one or more undefined or null values!");
    }
  }
  return (0, import_operators2.filter)(
    len === 1 ? (action) => (0, import_redux.isAction)(action) && action.type === types[0] : (action) => {
      if ((0, import_redux.isAction)(action)) {
        for (let i = 0; i < len; i++) {
          if (action.type === types[i]) {
            return true;
          }
        }
      }
      return false;
    }
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  StateObservable,
  __FOR_TESTING__resetDeprecationsSeen,
  combineEpics,
  createEpicMiddleware,
  ofType
});
//# sourceMappingURL=redux-observable.cjs.map