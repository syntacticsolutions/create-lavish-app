// src/StateObservable.ts
import { Observable, Subject } from "rxjs";
var StateObservable = class extends Observable {
  value;
  __notifier = new Subject();
  constructor(input$, initialState) {
    super((subscriber) => {
      const subscription = this.__notifier.subscribe(subscriber);
      if (subscription && !subscription.closed) {
        subscriber.next(this.value);
      }
      return subscription;
    });
    this.value = initialState;
    input$.subscribe((value) => {
      if (value !== this.value) {
        this.value = value;
        this.__notifier.next(value);
      }
    });
  }
};

// src/combineEpics.ts
import { merge } from "rxjs";
function combineEpics(...epics) {
  const merger = (...args) => merge(
    ...epics.map((epic) => {
      const output$ = epic(...args);
      if (!output$) {
        throw new TypeError(
          `combineEpics: one of the provided Epics "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
        );
      }
      return output$;
    })
  );
  try {
    Object.defineProperty(merger, "name", {
      value: `combineEpics(${epics.map((epic) => epic.name || "<anonymous>").join(", ")})`
    });
  } catch (e) {
  }
  return merger;
}

// src/createEpicMiddleware.ts
import { Subject as Subject2, from, queueScheduler } from "rxjs";
import { map, mergeMap, observeOn, subscribeOn } from "rxjs/operators";

// src/utils/console.ts
var deprecationsSeen = {};
var resetDeprecationsSeen = () => {
  deprecationsSeen = {};
};
var consoleWarn = typeof console === "object" && typeof console.warn === "function" ? console.warn.bind(console) : () => {
};
var warn = (msg) => {
  consoleWarn(`redux-observable | WARNING: ${msg}`);
};

// src/createEpicMiddleware.ts
function createEpicMiddleware(options = {}) {
  const QueueScheduler = queueScheduler.constructor;
  const uniqueQueueScheduler = new QueueScheduler(
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    queueScheduler.schedulerActionCtor
  );
  if (process.env.NODE_ENV !== "production" && typeof options === "function") {
    throw new TypeError(
      "Providing your root Epic to `createEpicMiddleware(rootEpic)` is no longer supported, instead use `epicMiddleware.run(rootEpic)`\n\nLearn more: https://redux-observable.js.org/MIGRATION.html#setting-up-the-middleware"
    );
  }
  const epic$ = new Subject2();
  let store;
  const epicMiddleware = (_store) => {
    if (process.env.NODE_ENV !== "production" && store) {
      warn(
        "this middleware is already associated with a store. createEpicMiddleware should be called for every store.\n\nLearn more: https://goo.gl/2GQ7Da"
      );
    }
    store = _store;
    const actionSubject$ = new Subject2();
    const stateSubject$ = new Subject2();
    const action$ = actionSubject$.asObservable().pipe(observeOn(uniqueQueueScheduler));
    const state$ = new StateObservable(
      stateSubject$.pipe(observeOn(uniqueQueueScheduler)),
      store.getState()
    );
    const result$ = epic$.pipe(
      map((epic) => {
        const output$ = epic(action$, state$, options.dependencies);
        if (!output$) {
          throw new TypeError(
            `Your root Epic "${epic.name || "<anonymous>"}" does not return a stream. Double check you're not missing a return statement!`
          );
        }
        return output$;
      }),
      mergeMap(
        (output$) => from(output$).pipe(
          subscribeOn(uniqueQueueScheduler),
          observeOn(uniqueQueueScheduler)
        )
      )
    );
    result$.subscribe(store.dispatch);
    return (next) => {
      return (action) => {
        const result = next(action);
        stateSubject$.next(store.getState());
        actionSubject$.next(action);
        return result;
      };
    };
  };
  epicMiddleware.run = (rootEpic) => {
    if (process.env.NODE_ENV !== "production" && !store) {
      warn(
        "epicMiddleware.run(rootEpic) called before the middleware has been setup by redux. Provide the epicMiddleware instance to createStore() first."
      );
    }
    epic$.next(rootEpic);
  };
  return epicMiddleware;
}

// src/operators.ts
import { isAction } from "redux";
import { filter } from "rxjs/operators";
function ofType(...types) {
  const len = types.length;
  if (process.env.NODE_ENV !== "production") {
    if (len === 0) {
      warn("ofType was called without any types!");
    }
    if (types.some((key) => key === null || key === void 0)) {
      warn("ofType was called with one or more undefined or null values!");
    }
  }
  return filter(
    len === 1 ? (action) => isAction(action) && action.type === types[0] : (action) => {
      if (isAction(action)) {
        for (let i = 0; i < len; i++) {
          if (action.type === types[i]) {
            return true;
          }
        }
      }
      return false;
    }
  );
}
export {
  StateObservable,
  resetDeprecationsSeen as __FOR_TESTING__resetDeprecationsSeen,
  combineEpics,
  createEpicMiddleware,
  ofType
};
//# sourceMappingURL=redux-observable.mjs.map